// file WCRCs.cpp - some CRC calculating routines
#include "WCRCs.hpp"

U16 CRC16_get(const void *Data, U32 DataLen, FUpdateCRC16 fucrc)
{
    U32 Addr = FPtoU32(Data);
    U16 CRC;
//    ConPrint("\n\rCRC_get:1\n\r");
    fucrc(NULL,0,CRC); // load initial value
//    ConPrint("\n\rCRC_get:2\n\r");
    while(DataLen)
    {
        U16 BlockSize = (DataLen > 32768ul) ? 32768u : (U16)DataLen;
        fucrc(U32toFP(Addr),BlockSize,CRC);
        Addr += BlockSize;
        DataLen -= BlockSize;
    }
    return CRC;
}

BOOL CRC16_is_OK(const void *Data, U32 DataLen, FUpdateCRC16 fucrc)
{
  return (DataLen<2) ? FALSE : CRC16_get(Data, DataLen-2, fucrc) == *(U16*)((U8 huge *)Data+(DataLen-2));
}

void CRC16_write(void *Data, U32 DataLen, FUpdateCRC16 fucrc)
{
  *(U16*)((U8 huge *)Data+DataLen) = CRC16_get(Data, DataLen, fucrc);
}

//***** CRC: Point-to-Point Protocol FCS16 (RFC1662)

void CRC16_PPP(const void *Data, U16 DataLen, U16 &CurCRC)
{
  static U16 Table[256] = {
    0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
    0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
    0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
    0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
    0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
    0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
    0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
    0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
    0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
    0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
    0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
    0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
    0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
    0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
    0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
    0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
    0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
    0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
    0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
    0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
    0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
    0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
    0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
    0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
    0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
    0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
    0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
    0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
    0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
    0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
    0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
    0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
  };
  if(DataLen)
  {
    U16 CRC = CurCRC;
    const U8 *Bytes=(U8*)Data;
    while (DataLen--)
      CRC = (CRC >> 8) ^ Table[(U8)CRC ^ *Bytes++];
    CurCRC = CRC;
  }
  else
    CurCRC = 0xFFFF;
}

//***** CRC: ModBus protocol CRC16

void CRC16_ModBus(const void *Data, U16 DataLen, U16 &CurCRC)
{
  static U16 Table[256] =
  {
    0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
    0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
    0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
    0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
    0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
    0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
    0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
    0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
    0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
    0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
    0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
    0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
    0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
    0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
    0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
    0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
    0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
    0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
    0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
    0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
    0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
    0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
    0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
    0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
    0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
    0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
    0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
    0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
    0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
    0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
    0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
    0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
  };
  if(DataLen)
  {
    U16 CRC = CurCRC;
    const U8 *Bytes=(U8*)Data;
    while (DataLen--)
      CRC = (CRC >> 8) ^ Table[(U8)CRC ^ *Bytes++];
    CurCRC = (CRC<<8) | (CRC>>8);
  }
  else
    CurCRC = 0xFFFF;
}


void CRC16_MTU05(const void *Data, U16 DataLen, U16 &CurCRC)
{
    if(DataLen==0)
        CurCRC = 0;
    else
    {
        U16 Crc = CurCRC;
        const U8 *Bytes=(U8*)Data;
        while (DataLen--)
        {
            U16 Temp = (*Bytes++) ^ (Crc >> 8);
            Temp ^= (Temp >> 4);
            Temp ^= (Temp >> 2);
            Temp ^= (Temp >> 1);
            Crc = (Crc << 8) ^ (Temp << 15) ^ (Temp << 2) ^ Temp;
        }
        CurCRC = Crc;
    }
}

//// CRC8 Dallas/Maxim (x^8 + x^5 + x^4 + 1)
//const U8 table[256] = {
//    0x00, 0x31, 0x62, 0x53, 0xC4, 0xF5, 0xA6, 0x97,
//    0xB9, 0x88, 0xDB, 0xEA, 0x7D, 0x4C, 0x1F, 0x2E,
//    0x43, 0x72, 0x21, 0x10, 0x87, 0xB6, 0xE5, 0xD4,
//    0xFA, 0xCB, 0x98, 0xA9, 0x3E, 0x0F, 0x5C, 0x6D,
//    0x86, 0xB7, 0xE4, 0xD5, 0x42, 0x73, 0x20, 0x11,
//    0x3F, 0x0E, 0x5D, 0x6C, 0xFB, 0xCA, 0x99, 0xA8,
//    0xC5, 0xF4, 0xA7, 0x96, 0x01, 0x30, 0x63, 0x52,
//    0x7C, 0x4D, 0x1E, 0x2F, 0xB8, 0x89, 0xDA, 0xEB,
//    0x3D, 0x0C, 0x5F, 0x6E, 0xF9, 0xC8, 0x9B, 0xAA,
//    0x84, 0xB5, 0xE6, 0xD7, 0x40, 0x71, 0x22, 0x13,
//    0x7E, 0x4F, 0x1C, 0x2D, 0xBA, 0x8B, 0xD8, 0xE9,
//    0xC7, 0xF6, 0xA5, 0x94, 0x03, 0x32, 0x61, 0x50,
//    0xBB, 0x8A, 0xD9, 0xE8, 0x7F, 0x4E, 0x1D, 0x2C,
//    0x02, 0x33, 0x60, 0x51, 0xC6, 0xF7, 0xA4, 0x95,
//    0xF8, 0xC9, 0x9A, 0xAB, 0x3C, 0x0D, 0x5E, 0x6F,
//    0x41, 0x70, 0x23, 0x12, 0x85, 0xB4, 0xE7, 0xD6,
//    0x7A, 0x4B, 0x18, 0x29, 0xBE, 0x8F, 0xDC, 0xED,
//    0xC3, 0xF2, 0xA1, 0x90, 0x07, 0x36, 0x65, 0x54,
//    0x39, 0x08, 0x5B, 0x6A, 0xFD, 0xCC, 0x9F, 0xAE,
//    0x80, 0xB1, 0xE2, 0xD3, 0x44, 0x75, 0x26, 0x17,
//    0xFC, 0xCD, 0x9E, 0xAF, 0x38, 0x09, 0x5A, 0x6B,
//    0x45, 0x74, 0x27, 0x16, 0x81, 0xB0, 0xE3, 0xD2,
//    0xBF, 0x8E, 0xDD, 0xEC, 0x7B, 0x4A, 0x19, 0x28,
//    0x06, 0x37, 0x64, 0x55, 0xC2, 0xF3, 0xA0, 0x91,
//    0x47, 0x76, 0x25, 0x14, 0x83, 0xB2, 0xE1, 0xD0,
//    0xFE, 0xCF, 0x9C, 0xAD, 0x3A, 0x0B, 0x58, 0x69,
//    0x04, 0x35, 0x66, 0x57, 0xC0, 0xF1, 0xA2, 0x93,
//    0xBD, 0x8C, 0xDF, 0xEE, 0x79, 0x48, 0x1B, 0x2A,
//    0xC1, 0xF0, 0xA3, 0x92, 0x05, 0x34, 0x67, 0x56,
//    0x78, 0x49, 0x1A, 0x2B, 0xBC, 0x8D, 0xDE, 0xEF,
//    0x82, 0xB3, 0xE0, 0xD1, 0x46, 0x77, 0x24, 0x15,
//    0x3B, 0x0A, 0x59, 0x68, 0xFF, 0xCE, 0x9D, 0xAC
//};

//***** CRC8 CCITT (x^8 + x^2 + x + 1)
U8 CRC8_CCITT_get(const void *Data, U16 DataLen)
{
    const U8 table[256] = {
        0x00,0x07,0x0E,0x09,0x1C,0x1B,0x12,0x15,0x38,0x3F,0x36,0x31,0x24,0x23,0x2A,0x2D,
        0x70,0x77,0x7E,0x79,0x6C,0x6B,0x62,0x65,0x48,0x4F,0x46,0x41,0x54,0x53,0x5A,0x5D,
        0xE0,0xE7,0xEE,0xE9,0xFC,0xFB,0xF2,0xF5,0xD8,0xDF,0xD6,0xD1,0xC4,0xC3,0xCA,0xCD,
        0x90,0x97,0x9E,0x99,0x8C,0x8B,0x82,0x85,0xA8,0xAF,0xA6,0xA1,0xB4,0xB3,0xBA,0xBD,
        0xC7,0xC0,0xC9,0xCE,0xDB,0xDC,0xD5,0xD2,0xFF,0xF8,0xF1,0xF6,0xE3,0xE4,0xED,0xEA,
        0xB7,0xB0,0xB9,0xBE,0xAB,0xAC,0xA5,0xA2,0x8F,0x88,0x81,0x86,0x93,0x94,0x9D,0x9A,
        0x27,0x20,0x29,0x2E,0x3B,0x3C,0x35,0x32,0x1F,0x18,0x11,0x16,0x03,0x04,0x0D,0x0A,
        0x57,0x50,0x59,0x5E,0x4B,0x4C,0x45,0x42,0x6F,0x68,0x61,0x66,0x73,0x74,0x7D,0x7A,
        0x89,0x8E,0x87,0x80,0x95,0x92,0x9B,0x9C,0xB1,0xB6,0xBF,0xB8,0xAD,0xAA,0xA3,0xA4,
        0xF9,0xFE,0xF7,0xF0,0xE5,0xE2,0xEB,0xEC,0xC1,0xC6,0xCF,0xC8,0xDD,0xDA,0xD3,0xD4,
        0x69,0x6E,0x67,0x60,0x75,0x72,0x7B,0x7C,0x51,0x56,0x5F,0x58,0x4D,0x4A,0x43,0x44,
        0x19,0x1E,0x17,0x10,0x05,0x02,0x0B,0x0C,0x21,0x26,0x2F,0x28,0x3D,0x3A,0x33,0x34,
        0x4E,0x49,0x40,0x47,0x52,0x55,0x5C,0x5B,0x76,0x71,0x78,0x7F,0x6A,0x6D,0x64,0x63,
        0x3E,0x39,0x30,0x37,0x22,0x25,0x2C,0x2B,0x06,0x01,0x08,0x0F,0x1A,0x1D,0x14,0x13,
        0xAE,0xA9,0xA0,0xA7,0xB2,0xB5,0xBC,0xBB,0x96,0x91,0x98,0x9F,0x8A,0x8D,0x84,0x83,
        0xDE,0xD9,0xD0,0xD7,0xC2,0xC5,0xCC,0xCB,0xE6,0xE1,0xE8,0xEF,0xFA,0xFD,0xF4,0xF3
    };
    U8 const *p = (U8 const *)Data;
    U8 c = 0;
    while(DataLen--)
        c = table[c ^ *(p++)];
    return c;
}

//***** CRC: ICP-DAS MiniOS 7 filesystem CRC16

U16 *OS7CRC16Table = NULL;

void MakeOS7CRC16Table(void)
{
  if(OS7CRC16Table) return;
  U16 *Table = (U16*)SYS::malloc(512);
  for(unsigned i=0;i<256;i++)
  {
    unsigned k=i<<8;
    U16 crc=0;
    for(unsigned j=0;j<8;j++)
    {
      if((crc^k)&0x8000)
        crc=(crc<<1)^0x1021;
      else
        crc<<=1;
      k<<=1;
    }
    Table[i] = crc;
  }
  OS7CRC16Table = Table;
}

void CRC16_OS7FS(const void *Data, U16 DataLen, U16 &CurCRC)
{
  MakeOS7CRC16Table();
  if(DataLen)
  {
    U16 CRC = CurCRC;
    const U8 *Bytes=(U8*)Data;
    while (DataLen--)
      CRC = OS7CRC16Table[ (CRC>>8) ^ *Bytes++ ] ^ (CRC<<8);
    CurCRC = CRC;
  }
  else
    CurCRC = 0x0000;
}

class __WCRCs {
public:
  ~__WCRCs()
  {
    if(OS7CRC16Table!=NULL) SYS::free(OS7CRC16Table);
  }
} __wcrcs;

